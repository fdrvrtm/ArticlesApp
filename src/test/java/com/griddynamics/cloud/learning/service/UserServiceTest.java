package com.griddynamics.cloud.learning.service;

import com.griddynamics.cloud.learning.dao.Permission;
import com.griddynamics.cloud.learning.dao.domain.Role;
import com.griddynamics.cloud.learning.dao.domain.User;
import com.griddynamics.cloud.learning.dao.repository.RoleRepository;
import com.griddynamics.cloud.learning.dao.repository.UserRepository;
import com.griddynamics.cloud.learning.web.dto.NewUserDto;
import com.griddynamics.cloud.learning.web.dto.UserWithRolesDto;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.test.context.junit4.SpringRunner;

import java.util.Collections;
import java.util.EnumSet;
import java.util.List;

import static org.junit.Assert.assertEquals;
import static org.mockito.Mockito.*;

@RunWith(SpringRunner.class)
public class UserServiceTest {

    @Mock
    private UserRepository userRepository;

    @Mock
    private RoleRepository roleRepository;

    @Mock
    private BCryptPasswordEncoder encoder;

    @InjectMocks
    private UserService service;

    @Test
    public void shouldSaveUserWhenRoleExistsAndReturnDtoAfterwards() {
        //given
        final Long id = 17L;
        final String username = "user";
        final String email = "user@gmail.com";
        final String password = "password";
        final String encodedPassword = "$2a$10$OSAs5O9bSvrAONTxZG7vgOa4JxcGRv8YY6Oh8Y0uCdlSHf6YIEr/6";
        final Permission permission = Permission.LIKE_ARTICLE;

        final Role userRole = new Role(23L, "USER", EnumSet.of(permission));
        final NewUserDto userToSaveDto = new NewUserDto(null, username, email, password);
        final User newUser = new User(null, username, email, encodedPassword, userRole, null);
        final User savedUser = new User(id, username, email, encodedPassword, userRole, null);

        when(encoder.encode(password)).thenReturn(encodedPassword);
        when(roleRepository.findAll()).thenReturn(List.of(userRole));
        when(userRepository.save(newUser)).thenReturn(savedUser);

        //when
        final UserWithRolesDto savedAndConvertedUser = service.saveUser(userToSaveDto);

        //then
        verify(encoder, times(1)).encode(password);
        verify(roleRepository, times(1)).findAll();
        verify(userRepository, times(1)).save(newUser);

        assertEquals(id, savedAndConvertedUser.getId());
        assertEquals(username, savedAndConvertedUser.getUsername());
        assertEquals(email, savedAndConvertedUser.getEmail());
        assertEquals(1, savedAndConvertedUser.getPermissions().size());

        final String userPermission = savedAndConvertedUser.getPermissions().iterator().next();
        assertEquals(permission.toString(), userPermission);
    }

    @Test
    public void shouldSaveUserWhenRoleNotExistsAndManageRoleProperly() {
        //given
        final Long id = 12L;
        final String username = "user";
        final String email = "user@gmail.com";
        final String password = "password";
        final String encodedPassword = "$2a$10$OSAs5O9bSvrAONTxZG7vgOa4JxcGRv8YY6Oh8Y0uCdlSHf6YIEr/6";
        final Permission permission = Permission.LIKE_ARTICLE;
        final String AUTOGENERATED_USER = "AUTOGENERATED USER";

        final Role generatedUserRole = Role.builder().name(AUTOGENERATED_USER).permissions(EnumSet.of(permission)).build();
        final NewUserDto userToSaveDto = new NewUserDto(null, username, email, password);
        final User newUser = new User(null, username, email, encodedPassword, generatedUserRole, null);
        final User savedUser = User.builder()
                .id(id)
                .username(username)
                .email(email)
                .password(encodedPassword)
                .role(generatedUserRole)
                .build();

        when(encoder.encode(password)).thenReturn(encodedPassword);
        when(roleRepository.findAll()).thenReturn(Collections.EMPTY_LIST);
        when(userRepository.save(newUser)).thenReturn(savedUser);

        //when
        final UserWithRolesDto savedAndConvertedUser = service.saveUser(userToSaveDto);

        //then
        verify(encoder, times(1)).encode(password);
        verify(roleRepository, times(1)).findAll();
        verify(userRepository, times(1)).save(newUser);

        assertEquals(id, savedAndConvertedUser.getId());
        assertEquals(username, savedAndConvertedUser.getUsername());
        assertEquals(email, savedAndConvertedUser.getEmail());
        assertEquals(1, savedAndConvertedUser.getPermissions().size());

        final String userPermission = savedAndConvertedUser.getPermissions().iterator().next();
        assertEquals(permission.toString(), userPermission);
    }
}
